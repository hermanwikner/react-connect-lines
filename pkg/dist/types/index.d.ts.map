{"mappings":";AAAA,YAAmB,QAAQ,GAAG,MAAM,GAAG,SAAS,CAAA;AAChD,cAAqB,OAAO,GAAG,QAAQ,GAAG,SAAS,CAAA;AAEnD;IACE,KAAK,CAAC,EAAE,MAAM,CAAA;IACd,IAAI,CAAC,EAAE,IAAI,CAAA;IACX,MAAM,CAAC,EAAE,MAAM,CAAA;IACf,EAAE,EAAE,MAAM,CAAA;CACX;AAED;IACE,WAAW,CAAC,EAAE,gBAAgB,EAAE,CAAA;IAChC,EAAE,EAAE,MAAM,CAAA;CACX;AMTD,sBAAuB,SAAQ,IAAI,CAAC,cAAc,EAAE,SAAS,CAAC;IAC5D,QAAQ,EAAE,MAAM,YAAY,CAAA;CAC7B;AAED,wBAAwB,KAAK,EAAE,YAAY,sEAyC1C;AMpBD;IACE,QAAQ,EAAE,cAAc,EAAE,CAAA;CAC3B;AAED,6BAA6B,KAAK,EAAE,iBAAiB,eAsMpD;AEnOD;IACE,QAAQ,EAAE,MAAM,SAAS,CAAA;CAC1B;AAQD,gCAAgC,KAAK,EAAE,oBAAoB,eAS1D","sources":["types.ts","elements/context.ts","elements/hooks.ts","elements/reducer.ts","elements/provider.tsx","elements/index.ts","Connect.tsx","lines/utils/pathify.ts","lines/utils/getElement.ts","lines/utils/getGroupedConnections.ts","lines/utils/getPathData.ts","lines/utils/index.ts","lines/ConnectLines.tsx","lines/index.ts","ConnectProvider.tsx","index.ts"],"sourcesContent":["export type Edge = 'bezier' | 'step' | undefined\nexport type Stroke = 'solid' | 'dashed' | undefined\n\nexport interface ConnectWithProps {\n  color?: string\n  edge?: Edge\n  stroke?: Stroke\n  id: string\n}\n\nexport interface ConnectElement {\n  connectWith?: ConnectWithProps[]\n  id: string\n}\n\nexport type ConnectElementsReducerPayload = ConnectElement & {\n  type: 'add' | 'remove'\n  element?: HTMLElement | null\n}\n\nexport type ConnectElementsDispatch = React.Dispatch<ConnectElementsReducerPayload>\n\nexport type ConnectElementsContextValue = {\n  elements: ConnectElement[]\n  dispatch: ConnectElementsDispatch\n}\n","import {createContext} from 'react'\nimport {ConnectElementsContextValue} from '../types'\n\nexport const ConnectElementsContext = createContext<ConnectElementsContextValue>({\n  elements: [],\n  dispatch: () => null,\n})\n","import {useContext} from 'react'\nimport {ConnectElementsContext} from './context'\n\nexport function useConnectElements() {\n  const ctxVal = useContext(ConnectElementsContext)\n\n  if (!ctxVal) {\n    throw new Error('Missing context value')\n  }\n\n  return useContext(ConnectElementsContext)\n}\n","import {ConnectElement, ConnectElementsContextValue, ConnectElementsReducerPayload} from '../types'\n\nexport function connectElementsReducer(\n  state: ConnectElementsContextValue,\n  payload: ConnectElementsReducerPayload\n): ConnectElementsContextValue {\n  const {type, id, element, connectWith} = payload\n\n  const exists = state?.elements?.some((l) => l.id === id)\n  const connectWithArr = connectWith || []\n  const node: ConnectElement & {element?: HTMLElement | null} = {\n    id,\n    element,\n    connectWith: connectWithArr,\n  }\n\n  if (type === 'add' && element) {\n    if (!exists) {\n      return {\n        ...state,\n        elements: [...state.elements, node],\n      }\n    }\n\n    if (exists) {\n      const next = [...state.elements].map((el) => {\n        if (el.id === id) {\n          return node\n        }\n\n        return el\n      })\n\n      return {...state, elements: next}\n    }\n\n    return state\n  }\n\n  if (type === 'remove') {\n    return {\n      ...state,\n      elements: state.elements\n        .map((x) => {\n          return {\n            ...x,\n            connectWith: x.connectWith?.filter((y) => y.id !== id),\n          }\n        })\n        .filter((el) => el.id !== id),\n    }\n  }\n\n  return state\n}\n","import {useMemo, useReducer} from 'react'\nimport {ConnectElementsContext} from './context'\nimport {connectElementsReducer} from './reducer'\n\ninterface ConnectElementsProviderProps {\n  children: React.ReactNode\n}\n\nexport function ConnectElementsProvider(props: ConnectElementsProviderProps) {\n  const {children} = props\n  const [state, dispatch] = useReducer(connectElementsReducer, {\n    elements: [],\n    dispatch: () => null,\n  })\n\n  const ctxVal = useMemo(\n    () => ({\n      elements: state.elements,\n      dispatch: dispatch,\n    }),\n    [state]\n  )\n\n  return (\n    <ConnectElementsContext.Provider value={ctxVal}>{children}</ConnectElementsContext.Provider>\n  )\n}\n","export * from './context'\nexport * from './hooks'\nexport * from './provider'\n","import React, {cloneElement, useCallback, useEffect, useMemo, useRef} from 'react'\nimport {useConnectElements} from './elements'\nimport {ConnectElement} from './types'\n\ninterface ConnectProps extends Omit<ConnectElement, 'element'> {\n  children: React.ReactElement\n}\n\nexport function Connect(props: ConnectProps) {\n  const {children, id, connectWith} = props\n  const {dispatch} = useConnectElements()\n  const nodeRef = useRef<HTMLElement>()\n\n  const handleAdd = useCallback(() => {\n    dispatch({\n      type: 'add',\n      id,\n      connectWith,\n      element: nodeRef.current,\n    })\n  }, [connectWith, dispatch, id])\n\n  const clone = useMemo(() => {\n    const {props: childProps} = children\n\n    return cloneElement(children, {\n      ...childProps,\n      ref: (node: HTMLElement) => {\n        nodeRef.current = node\n\n        if (typeof children === 'function') childProps.ref(node)\n      },\n    })\n  }, [children])\n\n  useEffect(() => {\n    handleAdd()\n  }, [props, handleAdd, nodeRef])\n\n  useEffect(() => {\n    return () => {\n      dispatch({\n        type: 'remove',\n        id,\n      })\n    }\n  }, [dispatch, id])\n\n  return clone\n}\n","import {Edge} from '../../types'\n\ninterface PathifyProps {\n  paths: {x: string | number; y: string | number}[]\n  edge?: Edge\n}\n\nexport const pathify = (props: PathifyProps) => {\n  const {paths, edge} = props\n\n  const path = `M ${paths\n    .map((p, index) => {\n      if (index === 1 && edge === 'step') return `${p.x} ${p.y}`\n      if (index === 1 && edge === 'bezier') return `C ${p.x} ${p.y}`\n\n      return `${p.x} ${p.y}`\n    })\n    .join(' ')}`\n\n  return path\n}\n","import {ConnectElement} from '../../types'\n\nexport function getElement(el: ConnectElement & {element?: HTMLElement}) {\n  if (!el.element) {\n    return document.querySelector(`#${el.id}`)\n  }\n\n  return el.element\n}\n","import {ConnectElement} from '../../types'\nimport {getElement} from './getElement'\n\nconst EMPTY_ARRAY: [] = []\n\ninterface GetGroupedConnectionsProps {\n  elements: ConnectElement[]\n}\n\nexport function getGroupedConnections(props: GetGroupedConnectionsProps) {\n  const {elements} = props\n\n  // const connections = elements?.map((e) => e.connectWith?.map((x) => x?.id)).flat()\n\n  const grouped = elements\n    .filter((e) => (e?.connectWith || EMPTY_ARRAY).length > 0)\n    .map((el) => {\n      const {connectWith} = el\n\n      // const connectionsLen = connections.filter((y) => y === el.id)?.length || 0\n\n      const connectEls = elements\n        .filter((c) => connectWith?.map((a) => a.id).includes(c.id))\n        .map((x) => {\n          return {\n            rect: getElement(x)?.getBoundingClientRect(),\n            color: connectWith?.find((a) => a.id === x.id)?.color || 'magenta',\n            edge: connectWith?.find((a) => a.id === x.id)?.edge || 'bezier',\n            stroke: connectWith?.find((a) => a.id === x.id)?.stroke || 'solid',\n            // connectionsLen: connectionsLen,\n          }\n        })\n\n      if (connectEls.length === 0) return\n\n      return {\n        from: {\n          rect: getElement(el)?.getBoundingClientRect(),\n        },\n        to: connectEls,\n      }\n    })\n    .filter(Boolean)\n\n  return grouped\n}\n","interface GetPathDataProps {\n  from?: {\n    rect: DOMRect | undefined\n  }\n  to?: {\n    rect: DOMRect | undefined\n  }\n}\n\nconst LINE_OFFSET = 9\nconst POS_OFFSET = 40\n\nfunction getPosition(props: {from: DOMRect; to: DOMRect}) {\n  const {from, to} = props\n\n  const allowYConnect =\n    from.left - POS_OFFSET < to.right && from.right + to.width > to.right - POS_OFFSET\n\n  const bottomToTop = from.bottom < to.top && allowYConnect\n  const topToBottom = from.top > to.bottom && allowYConnect\n  const rightToLeft = from.left > to.right\n  const leftToRight = from.right < to.left\n\n  if (bottomToTop) return 'bottom-to-top'\n  if (topToBottom) return 'top-to-bottom'\n  if (rightToLeft) return 'right-to-left'\n  if (leftToRight) return 'left-to-right'\n}\n\nexport function getPathData(props: GetPathDataProps) {\n  const {from, to} = props\n  const fromRect = from?.rect\n  const toRect = to?.rect\n\n  if (!fromRect || !toRect) return\n\n  const position = getPosition({from: fromRect, to: toRect})\n\n  switch (position) {\n    case 'bottom-to-top': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.bottom,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.top - LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'top-to-bottom': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.top,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.bottom + LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'right-to-left': {\n      return [\n        {\n          x: fromRect?.left,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.right + LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    case 'left-to-right': {\n      return [\n        {\n          x: fromRect?.right,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.left - LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    default:\n      return []\n  }\n}\n","export * from './pathify'\nexport * from './getGroupedConnections'\nexport * from './getPathData'\nexport * from './getElement'\n","import {useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {ConnectElement, Edge, Stroke} from '../types'\nimport {getElement, getGroupedConnections, getPathData, pathify} from './utils'\n\nconst SVG_STYLE: React.CSSProperties = {\n  position: 'fixed',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  pointerEvents: 'none',\n  width: '100%',\n  height: '100%',\n}\n\nconst DEFAULT_COLOR = 'magenta'\nconst EMPTY_ARRAY: [] = []\n\ntype PointsData = (\n  | {\n      rect: DOMRect | undefined\n      color: string | undefined\n      edge: Edge\n      stroke: Stroke\n      d: string\n    }\n  | undefined\n)[]\n\ninterface ConnectLinesProps {\n  elements: ConnectElement[]\n}\n\nexport function ConnectLines(props: ConnectLinesProps) {\n  const [pointsData, setPointsData] = useState<PointsData>(EMPTY_ARRAY)\n  const [isInteracting, setIsInteracting] = useState<boolean>(false)\n  const {elements} = props\n  const raf = useRef<number>()\n\n  /**\n   * Create array of all colors configured.\n   * These colors is used to render the svg markers (e.g arrows).\n   */\n  const colors = useMemo(\n    () =>\n      [\n        ...new Set([\n          ...elements.map((e) => e.connectWith?.map((c) => c?.color)).flat(),\n          DEFAULT_COLOR,\n        ]),\n      ].filter(Boolean),\n    [elements]\n  )\n\n  const handleCalcLines = useCallback(() => {\n    if (raf.current) {\n      window.cancelAnimationFrame(raf.current)\n    }\n\n    raf.current = window.requestAnimationFrame(() => {\n      /**\n       * The `getGroupedConnections` function returns:\n       *\n       *  {\n       *    from: DOMRect,\n       *    to: {\n       *       rect: DOMRect,\n       *       color: string,\n       *       edge: string,\n       *       stroke: string\n       *    }[]\n       *  }\n       */\n      const groupedConnections = getGroupedConnections({elements})\n\n      const points = groupedConnections\n        .map((data) => {\n          const {from, to: toArray} = data || {}\n\n          const pathDataArr = toArray?.map((to) => {\n            /**\n             * The `getPathData` function returns an array of objects with\n             * x and y coordinates for the line.\n             */\n            const pathData = getPathData({from: from, to: to})\n\n            if (!pathData) return\n\n            /**\n             * The `pathify` functions returns a svg-readable string of the coordinates\n             */\n            const path = pathify({paths: pathData, edge: to?.edge})\n\n            /**\n             * Dummy validation of the path\n             */\n            if (!/\\d/.test(path)) return\n\n            /**\n             * Return the path (d) together with other relevant data such as color, stroke, edge.\n             */\n            return {\n              d: path,\n              ...to,\n            }\n          })\n\n          return pathDataArr\n        })\n        .filter(Boolean)\n        .flat()\n\n      const data = points.filter((p) => Boolean(p))\n\n      setPointsData(data)\n    })\n  }, [elements])\n\n  /**\n   * Handle drag and drop gestures and update the paths\n   */\n  const handleStartInteracting = useCallback(() => {\n    setIsInteracting(true)\n  }, [])\n\n  const handleStopInteracting = useCallback(() => {\n    setIsInteracting(false)\n  }, [])\n\n  const handleUpdateLines = useCallback(() => {\n    if (isInteracting) handleCalcLines()\n  }, [handleCalcLines, isInteracting])\n\n  useEffect(() => {\n    handleCalcLines()\n  }, [handleCalcLines])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleCalcLines, {passive: true})\n    window.addEventListener('scroll', handleCalcLines, {passive: true})\n\n    return () => {\n      window.removeEventListener('resize', handleCalcLines)\n      window.removeEventListener('scroll', handleCalcLines)\n    }\n  }, [handleCalcLines])\n\n  const ro = useMemo(() => new ResizeObserver(handleCalcLines), [handleCalcLines])\n\n  useEffect(() => {\n    elements.forEach((el) => {\n      const element = getElement(el)\n\n      element?.addEventListener('mousedown', handleStartInteracting, {passive: true})\n      element?.addEventListener('mouseup', handleStopInteracting, {passive: true})\n      element?.addEventListener('mousemove', handleUpdateLines, {passive: true})\n      element?.addEventListener('touchstart', handleStartInteracting, {passive: true})\n      element?.addEventListener('touchend', handleStopInteracting, {passive: true})\n      element?.addEventListener('touchmove', handleUpdateLines, {passive: true})\n\n      if (element) {\n        ro.observe(element)\n      }\n    })\n\n    return () => {\n      elements.forEach((el) => {\n        const element = getElement(el)\n\n        element?.removeEventListener('mousedown', handleStartInteracting)\n        element?.removeEventListener('mouseup', handleStopInteracting)\n        element?.removeEventListener('mousemove', handleUpdateLines)\n        element?.removeEventListener('touchstart', handleStartInteracting)\n        element?.removeEventListener('touchend', handleStopInteracting)\n        element?.removeEventListener('touchmove', handleUpdateLines)\n\n        if (element) {\n          ro.disconnect()\n          ro.unobserve(element)\n        }\n      })\n    }\n  }, [\n    elements,\n    handleCalcLines,\n    handleStartInteracting,\n    handleStopInteracting,\n    handleUpdateLines,\n    ro,\n  ])\n\n  return useMemo(\n    () => (\n      <svg style={SVG_STYLE}>\n        {colors?.map((c) => (\n          <defs key={c}>\n            <marker\n              id={`triangle-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"5\"\n              orient=\"auto\"\n              refX=\"1\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={c} />\n              {/* <circle cx=\"5\" cy=\"5\" r=\"5\" fill={c} /> */}\n            </marker>\n          </defs>\n        ))}\n\n        {pointsData?.map((p) => {\n          return (\n            <path\n              id=\"p1\"\n              d={p?.d}\n              fill=\"none\"\n              key={p?.d}\n              markerEnd={`url(#triangle-${p?.color})`}\n              stroke={p?.color}\n              strokeWidth=\"2\"\n              strokeDasharray={p?.stroke === 'dashed' ? 4 : 0}\n              strokeLinejoin=\"round\"\n            />\n          )\n        })}\n      </svg>\n    ),\n    [colors, pointsData]\n  )\n}\n","export * from './ConnectLines'\n","import React from 'react'\nimport {ConnectElementsProvider, useConnectElements} from './elements'\nimport {ConnectLines} from './lines'\n\ninterface ConnectProviderProps {\n  children: React.ReactNode\n}\n\nfunction ConnectProviderInner() {\n  const {elements} = useConnectElements()\n\n  return <ConnectLines elements={elements} />\n}\n\nexport function ConnectProvider(props: ConnectProviderProps) {\n  const {children} = props\n\n  return (\n    <ConnectElementsProvider>\n      {children}\n      <ConnectProviderInner />\n    </ConnectElementsProvider>\n  )\n}\n","import {Connect} from './Connect'\nimport {ConnectProvider} from './ConnectProvider'\nimport {ConnectLines} from './lines/ConnectLines'\nimport type {ConnectElement} from './types'\n\nexport {Connect, ConnectProvider, ConnectLines, ConnectElement}\n"],"names":[],"version":3,"file":"index.d.ts.map"}